From 8afb024d6bb625727d610226a053bd6207463c65 Mon Sep 17 00:00:00 2001
From: Popax21 <popa21@popa21.at>
Date: Tue, 18 Jul 2023 01:44:07 +0200
Subject: [PATCH] [PATCH] Fix input latency by enabling use of exclusive
 fullscreen

---
 src/FNA3D_Driver_D3D11.c | 156 +++++++++++++++++++++++++++++++++++++--
 src/FNA3D_Driver_D3D11.h |   3 +
 2 files changed, 152 insertions(+), 7 deletions(-)

diff --git a/src/FNA3D_Driver_D3D11.c b/src/FNA3D_Driver_D3D11.c
index 9322bd4..de006ca 100644
--- a/src/FNA3D_Driver_D3D11.c
+++ b/src/FNA3D_Driver_D3D11.c
@@ -58,6 +58,18 @@
 #include <dxgi.h>
 #endif
 
+#ifndef DXGI_SWAP_EFFECT_FLIP_DISCARD
+#define DXGI_SWAP_EFFECT_FLIP_DISCARD 4
+#endif
+
+#ifndef DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING
+#define DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING 2048
+#endif
+
+#ifndef DXGI_PRESENT_ALLOW_TEARING
+#define DXGI_PRESENT_ALLOW_TEARING 0x00000200UL
+#endif
+
 #define ERROR_CHECK(msg) \
 	if (FAILED(res)) \
 	{ \
@@ -199,7 +211,11 @@ typedef struct D3D11SwapchainData
 {
 	IDXGISwapChain *swapchain;
 	ID3D11RenderTargetView *swapchainRTView;
+	DXGI_SWAP_CHAIN_FLAG swapchainFlags;
 	void *windowHandle;
+	uint8_t isFullScreen;
+	uint8_t inExclusiveFullScreen;
+	uint8_t reclaimFullScreenOnFocus;
 } D3D11SwapchainData;
 
 #define WINDOW_SWAPCHAIN_DATA "FNA3D_D3D11Swapchain"
@@ -1489,6 +1505,7 @@ static void D3D11_SwapBuffers(
 	FNA3D_Rect *destinationRectangle,
 	void* overrideWindowHandle
 ) {
+	HRESULT res;
 	D3D11Renderer *renderer = (D3D11Renderer*) driverData;
 	int32_t drawableWidth, drawableHeight;
 	FNA3D_Rect srcRect, dstRect;
@@ -1604,9 +1621,48 @@ static void D3D11_SwapBuffers(
 		);
 	}
 
-	/* Present! */
-	IDXGISwapChain_Present(swapchainData->swapchain, renderer->syncInterval, 0);
+	/* Check if we lost our exclusive fullscreen state */
+	if (swapchainData->inExclusiveFullScreen)
+	{
+		BOOL fullscreen;
+		res = IDXGISwapChain_GetFullscreenState(
+			swapchainData->swapchain,
+			&fullscreen,
+			NULL
+		);
+		if (FAILED(res) || !fullscreen)
+		{
+			FNA3D_LogInfo(
+				"Lost exclusive fullscreen state, switching back to windowed until focus is regained"
+			);
+			swapchainData->inExclusiveFullScreen = 0;
+			swapchainData->reclaimFullScreenOnFocus = 1;
+
+			/* Resize so that Present doesn't fail*/
+			D3D11_PLATFORM_ResizeSwapChain(renderer, swapchainData);
+		}
+	}
+	else if (	swapchainData->reclaimFullScreenOnFocus &&
+		GetFocus() == swapchainData->windowHandle	)
+	{
+		FNA3D_LogInfo("Regained focus, attempting to reclaim exclusive fullscreen state");
+		swapchainData->reclaimFullScreenOnFocus = 0;
 
+		res = D3D11_INTERNAL_SetFullScreenState(renderer, swapchainData, 1);
+		ERROR_CHECK("Couldn't reclaim exclusive fullscreen after focus loss")
+	}
+
+	/* Present! */
+	UINT flags = 0;
+	if (	(swapchainData->swapchainFlags & DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING) &&
+		!swapchainData->inExclusiveFullScreen &&
+		renderer->syncInterval == 0	)
+	{
+		flags |= DXGI_PRESENT_ALLOW_TEARING;
+	}
+	res = IDXGISwapChain_Present(swapchainData->swapchain, renderer->syncInterval, flags);
+	ERROR_CHECK("Present failed")
+	
 	/* Bind the faux-backbuffer now, in case DXGI unsets target state */
 	D3D11_SetRenderTargets(
 		(FNA3D_Renderer*) renderer,
@@ -2625,8 +2681,15 @@ static void D3D11_INTERNAL_CreateBackbuffer(
 			/* Resize the swapchain to the new window size */
 			ID3D11RenderTargetView_Release(swapchainData->swapchainRTView);
 			res = D3D11_PLATFORM_ResizeSwapChain(renderer, swapchainData);
-			ERROR_CHECK_RETURN("Could not resize swapchain",)
+			ERROR_CHECK_RETURN("Could not resize swapchain", )
+		}
+
+		/* Update fullscreen state */
+		if (swapchainData->isFullScreen != parameters->isFullScreen)
+		{
+			D3D11_INTERNAL_SetFullScreenState(renderer, swapchainData, parameters->isFullScreen);
 		}
+
 		useFauxBackbuffer = renderer->swapchainDataCount > 1;
 	}
 	else
@@ -2918,6 +2981,44 @@ static void D3D11_INTERNAL_SetPresentationInterval(
 	}
 }
 
+static HRESULT D3D11_INTERNAL_SetFullScreenState(
+	D3D11Renderer* renderer,
+	D3D11SwapchainData* swapchainData,
+	uint8_t isFullScreen
+) {
+	HRESULT res;
+
+	if (!SDL_GetHintBoolean("FNA3D_D3D11_NO_EXCLUSIVE_FULLSCREEN", SDL_FALSE)) {
+		swapchainData->isFullScreen = isFullScreen;
+		return S_OK;
+	}
+
+	/* Set exclusive fullscreen state */
+	res = IDXGISwapChain_SetFullscreenState(
+		swapchainData->swapchain,
+		isFullScreen,
+		NULL
+	);
+
+	if (res == DXGI_ERROR_NOT_CURRENTLY_AVAILABLE)
+	{
+		FNA3D_LogWarn(
+			"Exclusive fullscreen not available, silently falling back to borderless windowed"
+		);
+		swapchainData->isFullScreen = isFullScreen;
+		return S_OK;
+	}
+
+	ERROR_CHECK_RETURN("Couldn't set exclusive fullscreen state", res)
+
+	/* We need to resize the swapchain after a fullscreen transition */
+	res = D3D11_PLATFORM_ResizeSwapChain(renderer, swapchainData);
+	ERROR_CHECK_RETURN("Couldn't resize swapchain after fullscreen transition", res)
+
+	swapchainData->inExclusiveFullScreen = isFullScreen;
+	return S_OK;
+}
+
 static void D3D11_ResetBackbuffer(
 	FNA3D_Renderer *driverData,
 	FNA3D_PresentationParameters *presentationParameters
@@ -5142,6 +5243,13 @@ static FNA3D_Device* D3D11_CreateDevice(
 	int32_t i;
 	HRESULT res;
 
+	/* Force debug mode if the user set the hint */
+	if (SDL_GetHintBoolean("FNA3D_D3D11_FORCE_DEBUG", SDL_FALSE))
+	{
+		debugMode = 1;
+	}
+	debugMode = 1;
+
 	/* Allocate and zero out the renderer */
 	renderer = (D3D11Renderer*) SDL_malloc(sizeof(D3D11Renderer));
 	SDL_memset(renderer, '\0', sizeof(D3D11Renderer));
@@ -5346,6 +5454,16 @@ try_create_device:
 	return result;
 }
 
+static BOOL D3D11_INTERNAL_SwapChainCheckTearingSupport(IDXGIFactory1* factory) {
+	BOOL hasAllowTear = FALSE;
+	IDXGIFactory6* factory6;
+	if (SUCCEEDED(IDXGIFactory1_QueryInterface(factory, &D3D_IID_IDXGIFactory6, (void**) &factory6)))
+	{
+		IDXGIFactory6_CheckFeatureSupport(factory6, DXGI_FEATURE_PRESENT_ALLOW_TEARING, &hasAllowTear, sizeof(hasAllowTear));
+	}
+	return hasAllowTear;
+}
+
 #ifdef __WINRT__
 
 /* WinRT Platform Implementation */
@@ -5417,10 +5535,15 @@ static void D3D11_PLATFORM_CreateSwapChain(
 	swapchainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
 	swapchainDesc.BufferCount = 3;
 	swapchainDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
-	swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
+	swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
 	swapchainDesc.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED;
 	swapchainDesc.Flags = 0;
 
+	if (D3D11_INTERNAL_SwapChainCheckTearingSupport((IDXGIFactory1*)renderer->factory))
+	{
+		swapchainDesc.Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
+	}
+
 	/* Create the swap chain! */
 	res = IDXGIFactory2_CreateSwapChainForCoreWindow(
 		(IDXGIFactory2*) renderer->factory,
@@ -5434,8 +5557,10 @@ static void D3D11_PLATFORM_CreateSwapChain(
 
 	swapchainData = (D3D11SwapchainData*) SDL_malloc(sizeof(D3D11SwapchainData));
 	swapchainData->swapchain = swapchain;
+	swapchainData->swapchainFlags = swapchainDesc.Flags;
 	swapchainData->windowHandle = windowHandle;
 	swapchainData->swapchainRTView = NULL;
+	swapchainData->isFullScreen = 0;
 	SDL_SetWindowData((SDL_Window*) windowHandle, WINDOW_SWAPCHAIN_DATA, swapchainData);
 	if (renderer->swapchainDataCount >= renderer->swapchainDataCapacity)
 	{
@@ -5475,7 +5600,7 @@ static HRESULT D3D11_PLATFORM_ResizeSwapChain(
 		w,
 		h,
 		DXGI_FORMAT_UNKNOWN,	/* keep the old format */
-		0
+		swapchainData->swapchainFlags
 	);
 }
 
@@ -5676,9 +5801,24 @@ static void D3D11_PLATFORM_CreateSwapChain(
 	swapchainDesc.BufferCount = 3;
 	swapchainDesc.OutputWindow = dxgiHandle;
 	swapchainDesc.Windowed = 1;
-	swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
 	swapchainDesc.Flags = 0;
 
+	if (!SDL_GetHintBoolean("FNA3D_D3D11_NO_FLIP_MODEL", SDL_FALSE))
+	{
+		FNA3D_LogInfo("Using DXGI_SWAP_EFFECT_FLIP_DISCARD present model");
+		swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
+
+		if (D3D11_INTERNAL_SwapChainCheckTearingSupport((IDXGIFactory1*)renderer->factory))
+		{
+			swapchainDesc.Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
+		}
+	}
+	else
+	{
+		FNA3D_LogInfo("Using DXGI_SWAP_EFFECT_DISCARD present model");
+		swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
+	}
+
 	/* Create the swapchain! */
 	res = IDXGIFactory1_CreateSwapChain(
 		(IDXGIFactory1*) renderer->factory,
@@ -5726,8 +5866,10 @@ static void D3D11_PLATFORM_CreateSwapChain(
 
 	swapchainData = (D3D11SwapchainData*) SDL_malloc(sizeof(D3D11SwapchainData));
 	swapchainData->swapchain = swapchain;
+	swapchainData->swapchainFlags = swapchainDesc.Flags;
 	swapchainData->windowHandle = windowHandle;
 	swapchainData->swapchainRTView = NULL;
+	swapchainData->isFullScreen = 0;
 	SDL_SetWindowData((SDL_Window*) windowHandle, WINDOW_SWAPCHAIN_DATA, swapchainData);
 	if (renderer->swapchainDataCount >= renderer->swapchainDataCapacity)
 	{
@@ -5751,7 +5893,7 @@ static HRESULT D3D11_PLATFORM_ResizeSwapChain(
 		0,			/* get width from window */
 		0,			/* get height from window */
 		DXGI_FORMAT_UNKNOWN,	/* keep the old format */
-		0
+		swapchainData->swapchainFlags
 	);
 }
 
diff --git a/src/FNA3D_Driver_D3D11.h b/src/FNA3D_Driver_D3D11.h
index 7bf9318..92e3994 100644
--- a/src/FNA3D_Driver_D3D11.h
+++ b/src/FNA3D_Driver_D3D11.h
@@ -304,6 +304,9 @@ struct IDXGIFactory6
 	struct IDXGIFactory6Vtbl *lpVtbl;
 };
 
+#define IDXGIFactory6_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize)	\
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) )
+
 #define IDXGIFactory6_EnumAdapterByGpuPreference(This,Adapter,GpuPreference,riid,ppvAdapter)	\
 	( (This)->lpVtbl -> EnumAdapterByGpuPreference(This,Adapter,GpuPreference,riid,ppvAdapter) ) 
 
-- 
2.25.1

