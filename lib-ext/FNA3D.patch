From 4d9a8af60f851e55016ac20c7d45c1eac9549454 Mon Sep 17 00:00:00 2001
From: Popax21 <popa21@popa21.at>
Date: Tue, 18 Jul 2023 01:44:07 +0200
Subject: [PATCH] [PATCH] Fix input latency by enabling use of exclusive
 fullscreen

---
 src/FNA3D_Driver_D3D11.c | 306 ++++++++++++++++++++++++++++++++++++++-
 src/FNA3D_Driver_D3D11.h |   3 +
 2 files changed, 301 insertions(+), 8 deletions(-)

diff --git a/src/FNA3D_Driver_D3D11.c b/src/FNA3D_Driver_D3D11.c
index 9322bd4..d69d555 100644
--- a/src/FNA3D_Driver_D3D11.c
+++ b/src/FNA3D_Driver_D3D11.c
@@ -58,6 +58,18 @@
 #include <dxgi.h>
 #endif
 
+#ifndef DXGI_SWAP_EFFECT_FLIP_DISCARD
+#define DXGI_SWAP_EFFECT_FLIP_DISCARD 4
+#endif
+
+#ifndef DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING
+#define DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING 2048
+#endif
+
+#ifndef DXGI_PRESENT_ALLOW_TEARING
+#define DXGI_PRESENT_ALLOW_TEARING 0x00000200UL
+#endif
+
 #define ERROR_CHECK(msg) \
 	if (FAILED(res)) \
 	{ \
@@ -199,7 +211,11 @@ typedef struct D3D11SwapchainData
 {
 	IDXGISwapChain *swapchain;
 	ID3D11RenderTargetView *swapchainRTView;
+	DXGI_SWAP_CHAIN_FLAG swapchainFlags;
 	void *windowHandle;
+	uint8_t isFullScreen;
+	uint8_t inExclusiveFullScreen;
+	uint8_t reclaimFullScreenOnFocus;
 } D3D11SwapchainData;
 
 #define WINDOW_SWAPCHAIN_DATA "FNA3D_D3D11Swapchain"
@@ -1043,6 +1059,7 @@ static void D3D11_PLATFORM_GetDefaultAdapter(
 	IDXGIAdapter1 **adapter
 );
 
+static int D3D11_INTERNAL_SwapChainEventFilter(void* userdata, SDL_Event* event);
 static void D3D11_PLATFORM_CreateSwapChain(
 	D3D11Renderer *renderer,
 	FNA3D_SurfaceFormat backBufferFormat,
@@ -1057,6 +1074,12 @@ static void D3D11_INTERNAL_UpdateSwapchainRT(
 	D3D11SwapchainData *swapchainData,
 	DXGI_FORMAT format
 );
+static HRESULT D3D11_INTERNAL_SetFullScreenState(
+	D3D11Renderer* renderer,
+	D3D11SwapchainData* swapchainData,
+	uint8_t isFullScreen,
+	uint8_t noResize
+);
 
 /* Renderer Implementation */
 
@@ -1090,13 +1113,27 @@ static void D3D11_DestroyDevice(FNA3D_Device *device)
 	for (i = 0; i < renderer->swapchainDataCount; i += 1)
 	{
 		swapchainData = renderer->swapchainDatas[i];
+
 		ID3D11RenderTargetView_Release(swapchainData->swapchainRTView);
+
+		/* Exit exclusive fullscreen if we are in it */
+		if (swapchainData->inExclusiveFullScreen)
+		{
+			D3D11_INTERNAL_SetFullScreenState(
+				renderer,
+				swapchainData,
+				0,	/* no fullscreen */
+				0	/* no resize */
+			);
+		}
+
 		IDXGISwapChain_Release(swapchainData->swapchain);
 		SDL_SetWindowData(
 			(SDL_Window*) swapchainData->windowHandle,
 			WINDOW_SWAPCHAIN_DATA,
 			NULL
 		);
+		SDL_DelEventWatch(D3D11_INTERNAL_SwapChainEventFilter, swapchainData);
 		SDL_free(renderer->swapchainDatas[i]);
 	}
 	SDL_free(renderer->swapchainDatas);
@@ -1489,10 +1526,12 @@ static void D3D11_SwapBuffers(
 	FNA3D_Rect *destinationRectangle,
 	void* overrideWindowHandle
 ) {
+	HRESULT res;
 	D3D11Renderer *renderer = (D3D11Renderer*) driverData;
 	int32_t drawableWidth, drawableHeight;
 	FNA3D_Rect srcRect, dstRect;
 	D3D11SwapchainData *swapchainData;
+	BOOL fullscreenState;
 
 	/* Only the faux-backbuffer supports presenting
 	 * specific regions given to Present().
@@ -1580,6 +1619,40 @@ static void D3D11_SwapBuffers(
 
 	SDL_LockMutex(renderer->ctxLock);
 
+	/* Check if we lost our exclusive fullscreen state */
+	if (swapchainData->inExclusiveFullScreen)
+	{
+		res = IDXGISwapChain_GetFullscreenState(
+			swapchainData->swapchain,
+			&fullscreenState,
+			NULL
+		);
+		if (FAILED(res) || !fullscreenState)
+		{
+			FNA3D_LogInfo(
+				"Lost exclusive fullscreen state, switching back to windowed until focus is regained"
+			);
+			swapchainData->inExclusiveFullScreen = 0;
+			swapchainData->reclaimFullScreenOnFocus = 1;
+
+			/* Resize so that Present doesn't fail */
+			res = D3D11_INTERNAL_ResizeAfterFullScreenTransition(renderer, swapchainData);
+			ERROR_CHECK("Couldn't resize swapchain after focus loss")
+		}
+	}
+	else if (swapchainData->reclaimFullScreenOnFocus &&
+		SDL_GetKeyboardFocus() == (SDL_Window*)overrideWindowHandle	)
+	{
+		FNA3D_LogInfo("Regained focus, attempting to reclaim exclusive fullscreen state");
+		swapchainData->reclaimFullScreenOnFocus = 0;
+
+		res = D3D11_INTERNAL_SetFullScreenState(renderer, swapchainData, 1, 0);
+		if (FAILED(res))
+		{
+			FNA3D_LogWarn("Couldn't reclaim exclusive fullscreen after focus loss! Error Code: %08X", res);
+		}
+	}
+
 	if (renderer->backbuffer->type == BACKBUFFER_TYPE_D3D11)
 	{
 		/* Resolve the faux-backbuffer if needed */
@@ -1605,8 +1678,16 @@ static void D3D11_SwapBuffers(
 	}
 
 	/* Present! */
-	IDXGISwapChain_Present(swapchainData->swapchain, renderer->syncInterval, 0);
-
+	UINT flags = 0;
+	if (	(swapchainData->swapchainFlags & DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING) &&
+		!swapchainData->inExclusiveFullScreen &&
+		renderer->syncInterval == 0	)
+	{
+		flags |= DXGI_PRESENT_ALLOW_TEARING;
+	}
+	res = IDXGISwapChain_Present(swapchainData->swapchain, renderer->syncInterval, flags);
+	ERROR_CHECK("Present failed")
+	
 	/* Bind the faux-backbuffer now, in case DXGI unsets target state */
 	D3D11_SetRenderTargets(
 		(FNA3D_Renderer*) renderer,
@@ -2578,6 +2659,7 @@ static void D3D11_INTERNAL_CreateBackbuffer(
 	FNA3D_PresentationParameters *parameters
 ) {
 	uint8_t useFauxBackbuffer;
+	uint8_t needsResize;
 	HRESULT res;
 	D3D11_TEXTURE2D_DESC colorBufferDesc;
 	D3D11_RENDER_TARGET_VIEW_DESC colorViewDesc;
@@ -2619,14 +2701,35 @@ static void D3D11_INTERNAL_CreateBackbuffer(
 				(SDL_Window*) parameters->deviceWindowHandle,
 				WINDOW_SWAPCHAIN_DATA
 			);
+
+			needsResize = 0;
 		}
 		else
 		{
-			/* Resize the swapchain to the new window size */
-			ID3D11RenderTargetView_Release(swapchainData->swapchainRTView);
+			/* Release the old swapchain RT */
+			if (swapchainData->swapchainRTView != NULL)
+			{
+				ID3D11RenderTargetView_Release(swapchainData->swapchainRTView);
+				swapchainData->swapchainRTView = NULL;
+			}
+
+			needsResize = 1;
+		}
+
+		/* Update fullscreen state */
+		if (swapchainData->isFullScreen != parameters->isFullScreen)
+		{
+			D3D11_INTERNAL_SetFullScreenState(renderer, swapchainData, parameters->isFullScreen, 0);
+			needsResize = 1;
+		}
+
+		/* Resize the swapchain to the new window size */
+		if (needsResize)
+		{
 			res = D3D11_PLATFORM_ResizeSwapChain(renderer, swapchainData);
 			ERROR_CHECK_RETURN("Could not resize swapchain",)
 		}
+
 		useFauxBackbuffer = renderer->swapchainDataCount > 1;
 	}
 	else
@@ -2918,6 +3021,100 @@ static void D3D11_INTERNAL_SetPresentationInterval(
 	}
 }
 
+static HRESULT D3D11_INTERNAL_ResizeAfterFullScreenTransition(
+	D3D11Renderer* renderer,
+	D3D11SwapchainData* swapchainData
+) {
+	HRESULT res;
+	D3D11_RENDER_TARGET_VIEW_DESC swapchainViewDesc;
+	ID3D11Texture2D* swapchainTexture;
+	D3D11_TEXTURE2D_DESC swapchainTextureDesc;
+
+	/* Query the swapchain RT description */
+	if (swapchainData->swapchainRTView)
+	{
+		ID3D11RenderTargetView_GetDesc(swapchainData->swapchainRTView, &swapchainViewDesc);
+		ID3D11RenderTargetView_Release(swapchainData->swapchainRTView);
+	}
+
+	/* Query the current backbuffer size */
+	res = IDXGISwapChain_GetBuffer(
+		swapchainData->swapchain,
+		0,
+		&D3D_IID_ID3D11Texture2D,
+		(void**)&swapchainTexture
+	);
+	ERROR_CHECK_RETURN("Could not get buffer from swapchain", res)
+
+	ID3D10Texture2D_GetDesc(swapchainTexture, &swapchainTextureDesc);
+
+	ID3D11Texture2D_Release(swapchainTexture);
+	swapchainTexture = NULL;
+
+	/* Resize the backbuffer, keeping the size the same */
+	res = IDXGISwapChain_ResizeBuffers(
+		swapchainData->swapchain,
+		0,								/* keep # of buffers the same */
+		swapchainTextureDesc.Width,		/* keep width the same */
+		swapchainTextureDesc.Height,	/* keep height the same*/
+		DXGI_FORMAT_UNKNOWN,			/* keep the old format */
+		swapchainData->swapchainFlags
+	);
+	ERROR_CHECK_RETURN("Couldn't resize swapchain after focus loss", res)
+
+	/* Recreate the swapchain RT if we previously had one */
+	if (swapchainData->swapchainRTView)
+	{
+		D3D11_INTERNAL_UpdateSwapchainRT(renderer, swapchainData, swapchainViewDesc.Format);
+	}
+
+	return S_OK;
+}
+
+static HRESULT D3D11_INTERNAL_SetFullScreenState(
+	D3D11Renderer* renderer,
+	D3D11SwapchainData* swapchainData,
+	uint8_t isFullScreen,
+	uint8_t noResize
+) {
+	HRESULT res;
+
+	if (!SDL_GetHintBoolean("FNA3D_D3D11_NO_EXCLUSIVE_FULLSCREEN", SDL_FALSE))
+	{
+		/* Set exclusive fullscreen state */
+		res = IDXGISwapChain_SetFullscreenState(
+			swapchainData->swapchain,
+			isFullScreen,
+			NULL
+		);
+		if (res != DXGI_ERROR_NOT_CURRENTLY_AVAILABLE)
+		{
+			ERROR_CHECK_RETURN("Couldn't set exclusive fullscreen state", res)
+
+			/* We need to resize the swapchain after a fullscreen transition */
+			if (!noResize)
+			{
+				res = D3D11_INTERNAL_ResizeAfterFullScreenTransition(renderer, swapchainData);
+				ERROR_CHECK_RETURN("Couldn't resize swapchain after fullscreen transition", res)
+			}
+
+			swapchainData->inExclusiveFullScreen = isFullScreen;
+		}
+		else
+		{
+			FNA3D_LogWarn(
+				"Exclusive fullscreen not available, silently falling back to borderless windowed"
+			);
+
+			swapchainData->inExclusiveFullScreen = 0;
+		}
+	}
+
+	swapchainData->isFullScreen = isFullScreen;
+	swapchainData->reclaimFullScreenOnFocus = 0;
+	return S_OK;
+}
+
 static void D3D11_ResetBackbuffer(
 	FNA3D_Renderer *driverData,
 	FNA3D_PresentationParameters *presentationParameters
@@ -5142,6 +5339,12 @@ static FNA3D_Device* D3D11_CreateDevice(
 	int32_t i;
 	HRESULT res;
 
+	/* Force debug mode if the user set the hint */
+	if (SDL_GetHintBoolean("FNA3D_D3D11_FORCE_DEBUG", SDL_FALSE))
+	{
+		debugMode = 1;
+	}
+
 	/* Allocate and zero out the renderer */
 	renderer = (D3D11Renderer*) SDL_malloc(sizeof(D3D11Renderer));
 	SDL_memset(renderer, '\0', sizeof(D3D11Renderer));
@@ -5346,6 +5549,63 @@ try_create_device:
 	return result;
 }
 
+static BOOL D3D11_INTERNAL_SwapChainCheckTearingSupport(IDXGIFactory1* factory)
+{
+	BOOL hasAllowTear = FALSE;
+	IDXGIFactory6* factory6;
+	if (SUCCEEDED(IDXGIFactory1_QueryInterface(factory, &D3D_IID_IDXGIFactory6, (void**) &factory6)))
+	{
+		IDXGIFactory6_CheckFeatureSupport(factory6, DXGI_FEATURE_PRESENT_ALLOW_TEARING, &hasAllowTear, sizeof(hasAllowTear));
+	}
+	return hasAllowTear;
+}
+
+static int D3D11_INTERNAL_SwapChainEventFilter(void* userdata, SDL_Event* event)
+{
+	D3D11SwapchainData* swapchainData = (D3D11SwapchainData*)userdata;
+	HRESULT res;
+	BOOL isFullScreen;
+
+	if (event->type != SDL_WINDOWEVENT)
+	{
+		return 0;
+	}
+
+	if (event->window.event != SDL_WINDOWEVENT_RESIZED)
+	{
+		return 0;
+	}
+
+	/* Check if we lost our exclusive fullscreen state */
+	if (!swapchainData->inExclusiveFullScreen)
+	{
+		return 0;
+	}
+
+	res = IDXGISwapChain_GetFullscreenState(
+		swapchainData->swapchain,
+		&isFullScreen,
+		NULL
+	);
+
+	if (FAILED(res) || isFullScreen)
+	{
+		return 0;
+	}
+
+	/* Tell SDL2 to reenter fullscreen, as it might have become confused */
+	SDL_SetWindowFullscreen(
+		(SDL_Window*) swapchainData->windowHandle,
+		0
+	);
+	SDL_SetWindowFullscreen(
+		(SDL_Window*)swapchainData->windowHandle,
+		SDL_WINDOW_FULLSCREEN_DESKTOP
+	);
+	
+	return 0;
+}
+
 #ifdef __WINRT__
 
 /* WinRT Platform Implementation */
@@ -5417,10 +5677,15 @@ static void D3D11_PLATFORM_CreateSwapChain(
 	swapchainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
 	swapchainDesc.BufferCount = 3;
 	swapchainDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
-	swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
+	swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
 	swapchainDesc.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED;
 	swapchainDesc.Flags = 0;
 
+	if (D3D11_INTERNAL_SwapChainCheckTearingSupport((IDXGIFactory1*)renderer->factory))
+	{
+		swapchainDesc.Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
+	}
+
 	/* Create the swap chain! */
 	res = IDXGIFactory2_CreateSwapChainForCoreWindow(
 		(IDXGIFactory2*) renderer->factory,
@@ -5434,9 +5699,14 @@ static void D3D11_PLATFORM_CreateSwapChain(
 
 	swapchainData = (D3D11SwapchainData*) SDL_malloc(sizeof(D3D11SwapchainData));
 	swapchainData->swapchain = swapchain;
+	swapchainData->swapchainFlags = swapchainDesc.Flags;
 	swapchainData->windowHandle = windowHandle;
 	swapchainData->swapchainRTView = NULL;
+	swapchainData->isFullScreen = 0;
+	swapchainData->inExclusiveFullScreen = 0;
+	swapchainData->reclaimFullScreenOnFocus = 0;
 	SDL_SetWindowData((SDL_Window*) windowHandle, WINDOW_SWAPCHAIN_DATA, swapchainData);
+	SDL_AddEventWatch(D3D11_INTERNAL_SwapChainEventFilter, swapchainData);
 	if (renderer->swapchainDataCount >= renderer->swapchainDataCapacity)
 	{
 		renderer->swapchainDataCapacity *= 2;
@@ -5475,7 +5745,7 @@ static HRESULT D3D11_PLATFORM_ResizeSwapChain(
 		w,
 		h,
 		DXGI_FORMAT_UNKNOWN,	/* keep the old format */
-		0
+		swapchainData->swapchainFlags
 	);
 }
 
@@ -5676,9 +5946,24 @@ static void D3D11_PLATFORM_CreateSwapChain(
 	swapchainDesc.BufferCount = 3;
 	swapchainDesc.OutputWindow = dxgiHandle;
 	swapchainDesc.Windowed = 1;
-	swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
 	swapchainDesc.Flags = 0;
 
+	if (!SDL_GetHintBoolean("FNA3D_D3D11_NO_FLIP_MODEL", SDL_FALSE))
+	{
+		FNA3D_LogInfo("Using DXGI_SWAP_EFFECT_FLIP_DISCARD present model");
+		swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
+
+		if (D3D11_INTERNAL_SwapChainCheckTearingSupport((IDXGIFactory1*)renderer->factory))
+		{
+			swapchainDesc.Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
+		}
+	}
+	else
+	{
+		FNA3D_LogInfo("Using DXGI_SWAP_EFFECT_DISCARD present model");
+		swapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
+	}
+
 	/* Create the swapchain! */
 	res = IDXGIFactory1_CreateSwapChain(
 		(IDXGIFactory1*) renderer->factory,
@@ -5726,9 +6011,14 @@ static void D3D11_PLATFORM_CreateSwapChain(
 
 	swapchainData = (D3D11SwapchainData*) SDL_malloc(sizeof(D3D11SwapchainData));
 	swapchainData->swapchain = swapchain;
+	swapchainData->swapchainFlags = swapchainDesc.Flags;
 	swapchainData->windowHandle = windowHandle;
 	swapchainData->swapchainRTView = NULL;
+	swapchainData->isFullScreen = 0;
+	swapchainData->inExclusiveFullScreen = 0;
+	swapchainData->reclaimFullScreenOnFocus = 0;
 	SDL_SetWindowData((SDL_Window*) windowHandle, WINDOW_SWAPCHAIN_DATA, swapchainData);
+	SDL_AddEventWatch(D3D11_INTERNAL_SwapChainEventFilter, swapchainData);
 	if (renderer->swapchainDataCount >= renderer->swapchainDataCapacity)
 	{
 		renderer->swapchainDataCapacity *= 2;
@@ -5751,7 +6041,7 @@ static HRESULT D3D11_PLATFORM_ResizeSwapChain(
 		0,			/* get width from window */
 		0,			/* get height from window */
 		DXGI_FORMAT_UNKNOWN,	/* keep the old format */
-		0
+		swapchainData->swapchainFlags
 	);
 }
 
diff --git a/src/FNA3D_Driver_D3D11.h b/src/FNA3D_Driver_D3D11.h
index 7bf9318..92e3994 100644
--- a/src/FNA3D_Driver_D3D11.h
+++ b/src/FNA3D_Driver_D3D11.h
@@ -304,6 +304,9 @@ struct IDXGIFactory6
 	struct IDXGIFactory6Vtbl *lpVtbl;
 };
 
+#define IDXGIFactory6_CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize)	\
+    ( (This)->lpVtbl -> CheckFeatureSupport(This,Feature,pFeatureSupportData,FeatureSupportDataSize) )
+
 #define IDXGIFactory6_EnumAdapterByGpuPreference(This,Adapter,GpuPreference,riid,ppvAdapter)	\
 	( (This)->lpVtbl -> EnumAdapterByGpuPreference(This,Adapter,GpuPreference,riid,ppvAdapter) ) 
 
-- 
2.25.1

